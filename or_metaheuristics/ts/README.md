# 禁忌搜索算法

## Reference

- https://en.wikipedia.org/wiki/Tabu_search
- Using Tabu Search Heuristics in Solving the Vehicle Routing Problem with Time Windows: Application to a Mauritian Firm
- https://iccl.inf.tu-dresden.de/w/images/b/b6/PSSAIWS2019_L4.pdf
- https://wwwcourses.sens.buffalo.edu/mae552/lectures/PDFS/Lecture23-3-18-2002_Web.pdf
- https://mp.weixin.qq.com/s/nEP4CCNuMZ5xo822-efGxg




 
禁忌搜索最早由弗雷德·格洛弗（Fred Glover）于1986年在其发表的一篇论文中提出. 禁忌搜索的诞生，是因为经济、工程、商业和科学等领域中，大量棘手的组合优化问题需要在实际的时间限制内得到解决. 格洛弗认为，禁忌搜索是一种元启发式算法，它引导局部启发式算法探索超越局部最优的解空间 .   

禁忌搜索最初类似普通的局部搜索，从一个解到下一个解进行迭代，直至满足某些停止准则，同时借助一些策略避免陷入局部最优. 事实上，诸如下降法之类的局部搜索，往往会得到一个局部最优解，而这个解可能是也可能不是全局最优解（全局最优解指对于所有 $ x \in X $，能使目标函数 $ f(x) $ 最小化的解）.   

对于每个 $ x \in X $（其中 $ X $ 表示对决策变量向量 $ x $ 的约束），都关联一个邻域 $ N(x) \subset X $，通过移动操作，可从 $ x $ 到达 $ N(x) $ 中的每个解 $ x’ $（格洛弗和拉古纳，1997）.   

禁忌搜索区别于其他搜索方法的典型特征，是其对“记忆”的运用，这种记忆兼具**显式**与**属性式**特点. 显式记忆存储完整的解，由搜索过程中访问过的精英解组成. 通过调用记忆中的精英解及其邻域，局部搜索得以扩展（格洛弗和拉古纳，1997）. 相反，属性式记忆用于指导搜索过程，存储从一个解移动到另一个解时，与解属性变化相关的信息. 例如，在图中被删除、移除或重新定位的节点和弧，就是属性的一种体现. 




## 核心思想
1. **邻域探索**：从当前解出发，对其邻域内的所有可能解进行逐一评估. 
2. **禁忌机制**：借助“禁忌表”来记录近期已经访问过的解或者移动操作，以此避免搜索过程出现循环. 
3. **特赦规则**：在某些特定情况下，即便某个解处于禁忌状态，也可以对其进行解禁，从而确保不会错过潜在的优质解. 

## 关键组成部分
1. **禁忌表（Tabu List）**
    - **功能**：用于记录近期所采取的移动操作或者解，防止算法重复选择这些内容. 
    - **示例**：假如在旅行商问题中，刚刚交换了城市A和城市B的位置，那么在接下来的若干步（比如5步）内，再次交换这两个城市的操作就会被禁止. 
    - **管理方式**：可以采用队列或者栈的结构来管理禁忌表，当表的容量满了之后，按照先进先出（FIFO）或者最近最少使用（LRU）的策略删除旧的记录. 
2. **邻域生成**
    - 要依据具体问题来设计邻域的结构. 例如，在旅行商问题中，可以通过交换两个城市的位置来生成新的解；在调度问题中，则可以交换两个任务的执行顺序. 
3. **特赦准则**
    - 当一个被禁忌的解满足某些条件时，比如它的目标函数值比当前最优解还要好，就可以对其解除禁忌. 

## 算法步骤
以下伪代码展示了上文所述禁忌搜索算法的简化版本. 此实现包含基础的短期记忆结构，但没有中间或长期记忆结构，且禁忌表存储完整的解.

### 初始设置
1. 设初始解为 $s_0$，将全局最优解 $s_{Best}$ 初始化为 $s_0$，即 $s_{Best} \leftarrow s_0$. 
2. 把当前最佳候选解 $s_{Candidate}^*$ 也初始化为 $s_0$，即 $s_{Candidate}^* \leftarrow s_0$. 
3. 构建一个空的禁忌表 $T$，也就是 $T \leftarrow \varnothing$. 
4. 将初始解 $s_0$ 加入到禁忌表 $T$ 中，即 $T \leftarrow T \cup \{s_0\}$. 

### 迭代搜索
开始一个循环，只要不满足终止条件，就持续进行以下操作：
1. **生成邻域解**：通过邻域生成函数 $N(s)$ 得到当前最佳候选解 $s_{Candidate}^*$ 的邻域解集合 $S_{Neighborhood}$，即 $S_{Neighborhood} \leftarrow N(s_{Candidate}^*)$. 
2. **初始化最佳候选解适应度**：把当前最佳候选解的适应度 $f_{Candidate}^*$ 初始化为负无穷，即 $f_{Candidate}^* \leftarrow -\infty$. 
3. **遍历邻域解**：
    - 对邻域解集合 $S_{Neighborhood}$ 中的每个候选解 $s_{Candidate}$ 进行如下操作：
        - 若 $s_{Candidate}$ 不在禁忌表 $T$ 中，并且其适应度 $f(s_{Candidate})$ 大于当前最佳候选解的适应度 $f_{Candidate}^*$，则执行：
            - 更新当前最佳候选解 $s_{Candidate}^* \leftarrow s_{Candidate}$. 
            - 更新当前最佳候选解的适应度 $f_{Candidate}^* \leftarrow f(s_{Candidate}^*)$. 
        - 若 $s_{Candidate}$ 在禁忌表 $T$ 中，并且其适应度 $f(s_{Candidate})$ 大于当前最佳候选解的适应度 $f_{Candidate}^*$，则执行：
            - 更新当前最佳候选解 $s_{Candidate}^* \leftarrow s_{Candidate}$. 
            - 更新当前最佳候选解的适应度 $f_{Candidate}^* \leftarrow f(s_{Candidate}^*)$.
            - 将$s_{Candidate}$从禁忌表中移除$T\leftarrow T$\\ $\{s_{Candidate}\}$
4. **检查是否找到有效解**：
    - 若遍历完邻域解后，当前最佳候选解的适应度 $f_{Candidate}^*$ 仍然是负无穷，说明没有找到合适的非禁忌解，此时终止循环. 
5. **更新全局最优解**：
    - 若当前最佳候选解的适应度 $f_{Candidate}^*$ 大于全局最优解的适应度 $f(s_{Best})$，则更新全局最优解 $s_{Best} \leftarrow s_{Candidate}^*$. 
6. **更新禁忌表**：
    - 将当前最佳候选解 $s_{Candidate}^*$ 加入到禁忌表 $T$ 中，即 $T \leftarrow T \cup \{s_{Candidate}^*\}$. 
    - 若禁忌表 $T$ 的元素数量超过了预设的最大规模 $M$，则移除禁忌表中最早加入的元素. 

### 结束搜索
当满足终止条件时，循环结束，返回全局最优解 $s_{Best}$.  


## 特点与优势
- **避免局部最优**：通过禁止重复访问解，能够引导搜索过程探索更广阔的解空间. 
- **灵活运用**：可以根据实际问题灵活地设计邻域结构和禁忌规则. 
- **高效性**：相较于完全枚举的方法，该算法的计算成本更低. 


## 属性式禁忌表

在上述的伪代码中禁忌对象是以状态本身，另外也可以以状态分量以及分量的变化作为禁忌对象. 例如：在TSP问题中，解的变化为：$(1,2,3,4)\rightarrow (1,3,4,2)$，可将元素$\{3, 4\}$变化的过程作为禁忌对象. 

